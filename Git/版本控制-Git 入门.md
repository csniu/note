Git 是一个分布式版本控制系统，可运行在各种主流操作系统上，如Linux、Mac、Unix、Windows。

你既可以像集中式版本控制系统那样使用中心仓库工作，也可使用[分布式工作流程](https://git-scm.com/book/zh/v2/%E5%88%86%E5%B8%83%E5%BC%8F-Git-%E5%88%86%E5%B8%83%E5%BC%8F%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B)方式工作。使开发者间的协作变得更加灵活多样。

而且你既可以通过命令行方式操作 Git，又可以使用可视化的工具（[Gitk](https://git-scm.com/book/zh/v2/%E9%99%84%E5%BD%95-A%3A-%E5%9C%A8%E5%85%B6%E5%AE%83%E7%8E%AF%E5%A2%83%E4%B8%AD%E4%BD%BF%E7%94%A8-Git-%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2)）工作。甚至可以使用以下工具将 Git 集成到你现有的工程中。
- [Libgit2](https://libgit2.org/)：是一个可移植、纯C语言实现的Git开发包，作为一款带有稳固API的可重入链接库，libgit2允许你使用**任何语言**来编写Git应用。
- [JGit](https://www.eclipse.org/jgit/)：使用 Java 实现的 Git 库。
- [go-git](https://github.com/src-d/go-git)：使用 Go 实现的 Git 库。
- [Dulwich](https://www.dulwich.io/)：使用 Python 实现的 Git 库。

<!-- more -->

# 配置
Git 用户配置有三种级别，从高到低依次为：
- system：系统级，整个系统只有一个。配置文件地址为 `$(prefix)/etc/gitconfig`.
- global：用户级，一个系统用户一个。配置文件为 `~/.gitconfig`
- local：代码库级别，每个代码库可以有一个。配置文件为仓库路径下的 `.git/config`

读取配置由高到低，逐级覆盖。也就是说如果三级都配置了，最后使用的是 local 级。


##### 查看配置:
```
git config --list  # 所有
git config --list --local  # 相应级别下的所有
git config --loacl  user.name  # 某一配置项
```

##### 添加/修改配置：
```
git conﬁg --global user.email your_email@domain.com
```

##### 删除配置：
```
git config --unset --local user.name
```

一般情况下我们自需要配置一个全局的用户名和邮箱即可，用于提交时表明身份。
```
git config --global user.name "Your Name"
git config --global user.email "email@example.com"
```

更加详细的配置项及其介绍请查看[官方文档](https://git-scm.com/book/zh/v2/%E9%99%84%E5%BD%95-C%3A-Git-%E5%91%BD%E4%BB%A4-%E8%AE%BE%E7%BD%AE%E4%B8%8E%E9%85%8D%E7%BD%AE)。


# 内部原理
***先了解其内部原理，可以帮助我们更好的理解Git。当然你也可以只了解其使用方法，或者你也可以先了解使用方法后再来阅读也行。***

仓库下的`.git`子目录，存储了仓库的所有信息。主要有以下结构：
- config: 存储仓库的配置信息。
- description: 仅供 GitWeb 程序使用，一般无需关心。
- hooks/:包括客户端或服务端的钩子脚本（hook scripts）。
- info/:包含一个全局性排除（global exclude）文件， 用以放置那些不希望被记录在 `.gitignore` 文件中的忽略模式（ignored patterns）。
- **HEAD**:指向当前所在分支
- **objects/**:存储所有**对象**内容。
- **refs/**:存储指向数据（分支、远程仓库和标签等）的提交对象的**指针**。
- **index** :暂存区信息。


## 三种对象
Git 的核心是一个简单的键值对数据库（key-value data store）。你可以向 Git 仓库中插入任意类型的内容，它会返回一个唯一的键，通过该键可以在任意时刻再次取回该内容。


键是由“待存储数据“加上“头部信息”拼接后，再通过SHA-1算法计算出的一个长度为40个字符串。

“头部信息” = 关键字 + 一个空格 + “待存储数据”的长度 + 一个空字节。

存储方式：
- 键的前两位作为子目录的文件名，
- 键的后38位作为文件名。
- 文件内容为使用`zlib`压缩后的拼接内容。


### 数据对象（blob object）
“待存储数据”几乎可以是任何东西（文本、二进制文件等）。

“头部信息关键字”为`blob`。

##### 创建对象
```
echo 'test content' | git hash-object -w --stdin
# d670460b4b4aece5915caf5c68d12f560a9fe3e4
```
- `-w`:保持到数据库中（object目录）。
- `--stdin`:从标准输入读入，或者在该命令后指定文件路径。
- 会创建`.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4`文件，文件内容为`blob \`

##### 查询对象
```
git cat-file -p d670460b4b4aece5915caf5c68d12f560a9fe3e4
# test content
```

数据对象解决的单个文件的版本管理问题，但是还不完美。主要有：
- 需要记住每一个版本的SHA-1值。
- 只保存了文件内容，文件名等信息并没有被保存。

### 树对象（tree object）
树对象是为了解决文件名无法保存的问题，它允许我们将多个文件组织在一起。Git 以一种类似于 UNIX 文件系统的方式存储内容，但作了些许简化。 所有内容均以树对象和数据对象的形式存储。

一个树对象包含了一条或多条记录，每条记录含有一个指向数据对象或者子树对象的 SHA-1 指针（键），以及相应的模式、类型、文件名信息。

“待存储数据”由所有记录组成。“头部信息关键字”为`tree`。

##### 查询对象
```
git cat-file -p master^{tree}
# 100644 blob a906cb2a4a904a152e80877d4088654daad0c859      README
# 100644 blob 8f94139338f9404f26296befa88755fc2598c289      Rakefile
# 040000 tree 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0      lib
```
- 查看 master 分支上最新的提交所指向的树对象

```
git cat-file -p 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0
# 100644 blob 47c6340d6459e05787f644c2447d2595f5d3a54b      simplegit.rb
```
- 查看指定树对象内容

##### 创建对象
Git是根据某一时刻暂存区的状态来创建并记录一个对应的树对象。这也就是为什么要先将修改加到暂存区，再提交的原因。

###### 更新暂存区
```
git update-index --add --cacheinfo 100644 83baae61804e65cc73a7201a7252750c76066a30 test.txt
```
- `--add`：将文件加到暂存区，第一次开始记录时需要。
- `--cacheinfo`：将已经保持Git数据库中的对象加到暂存区。
- `100644`: 文件模式。参考与UNIX文件模式，但主要有三种：
    - 100644：普通文件。
    - 100755：可执行文件。
    - 120000：符号链接。

```
git update-index --add new.txt
```
- 将工作区中的文件加到暂存区

```
git read-tree --prefix=bak d8329fc1cc938780ffdd9f94e0d364e0ea74f579
```
- 将一个树对象读到暂存区
- 这是再创建新的树对象时就会包括该子树对象了。



###### 创建树对象
```
git write-tree
# d8329fc1cc938780ffdd9f94e0d364e0ea74f579
```
- 根据当前的暂存区，创建一个树对象。


树对象帮我们解决了前面的两个问题，但是同时又产生了新的问题：
- 需要记住所有的树对象的SHA-1值（键）。
- 不能保存每一次提交的信息（谁提交的？什么时候？提交的什么？等）。


### 提交对象
提交对象就是用来解决上面问题的。创建一个提交对象需要：
- 一个顶级树对象。
- 该提交对象的父提交对象。（如果有）
- 提交人的信息。（在三种配置级别下查找）
- 提交的时间。
- 提交的日志信息。

通过父对象以及提交时间，就串起了一个完整的版本更新状态。

“头部信息关键字”为`commit`。

##### 查询对象
```
git cat-file -p <sha1>
```

##### 创建对象
```
git commit-tree <tree_sha1> [-p <parent_commit_sha1>] [-m <message>]
```

##### 查看历史提交信息
```
git log  <commit_sha1>
```

***Git 所做的工作实质就是将被改写的文件保存为数据对象， 更新暂存区，记录树对象，最后创建一个指明了顶层树对象和父提交的提交对象。***


## 引用
从数据对象到树对象，再到提交对象，逐级简化后我们还是需要记住最后提交SHA-1值。

为了解决这个问题，你可能会很自然的想到，可以把该值保存到一个固定的文件中（或者更简单的将该值作为文件名）。这样每次我们只需要查看该文件就好了。

没错 Git 也是这么想的，这就是 Git 中的引用。Git 将其保存在`.git/refs`中。

这基本就是 Git 分支的本质：一个指向某一系列提交之首的指针或引用。

#### 更新引用
```
echo 1a410efbd13591db07496601ebc7a059dd55cfe9 > .git/refs/heads/master  # 不过不建议直接操控文件
git update-ref refs/heads/master 1a410efbd13591db07496601ebc7a059dd55cfe9
```

#### 查看引用
```
git log --pretty=oneline master
```

#### 创建新分支
```
git update-ref refs/heads/test cac0ca
```

### HEAD 引用
HEAD 文件通常是一个符号引用（symbolic reference），指向目前所在的分支。 所谓符号引用，表示它是一个指向其他引用的指针。

除了直接操作文件，可以使用更安全的命令`git symbolic-ref`。
```
git symbolic-ref HEAD  # 查看
git symbolic-ref HEAD refs/heads/test  # 更新
```

### 标签引用
除了前面说到的三种对象外，还有一种“标签对象（tag object）”。其包含一个标签创建者信息、一个日期、一段注释信息，以及一个指针。

标签对象非常类似于一个提交对象。主要的区别在于，标签对象通常指向一个提交对象，而不是一个树对象。 它像是一个永不移动的分支引用（永远指向同一个提交对象），只不过给这个提交对象加上一个更友好的名字。


##### 轻量标签
```
git update-ref refs/tags/v1.0 cac0cab538b970a37ea1e769cbbde608743bc96d
```
##### 附注标签
```
git tag -a v1.1 1a410efbd13591db07496601ebc7a059dd55cfe9 -m 'test tag'
```
- Git 会创建一个标签对象，并记录一个引用来指向该标签对象。
```
cat .git/refs/tags/v1.1  # 查看标签对象
git cat-file -p 9585191f37f7b0fb9444f35a9bf50de191beadc2
```

### 远程引用（remote reference）
如果你添加了一个远程版本库并对其执行过推送操作，Git 会记录下最近一次推送操作时每一个分支所对应的值，并保存在 refs/remotes 目录下。 

远程引用是只读的，你永远不能通过 commit 命令来更新远程引用。

## 包文件
在说数据对象时说到，每一个数据对象都会存储文件的所有内容。这样做的好处是简化了数据结构，但是缺点是增加存储空间。

为了节省空间，Git会根据文件名和文件大小将其打包。打包文件存放在：`.git/objects/pack`

#### 打包
```
git gc
```
- Git 时常会自动对仓库进行重新打包以节省空间。当然你也可以随时手动执行.
- 会创建一个包文件(`.pack`)和一个索引文件(`.idx`)
    -  包文件包含了从文件系统中移除的所有对象的内容。
    -  索引文件包含了包文件的偏移信息。
- 最新的对象会保存完整的数据，之前的对象只会保存差异内容。

#### 查看打包的对象
```
git verify-pack -v .git/objects/pack/pack-978e03944f5c581011e6998cd0e9e30000905586.idx
```


# 基本使用
如果你是先了解了Git的内部原理，那么你在使用中更能知其所以然。如果你是想先了解它基本用法也没关系。你只需要记住Git的基本流程即可：
1. 在工作区中修改数据。
2. 将修改内容添加到暂存区。
3. 将暂存区内容提交到Git历史版本中。

## 获取仓库
通常有两种获取 Git 项目仓库的方式：
- 将尚未进行版本控制的本地目录转换为 Git 仓库；
- 从其它服务器克隆一个已存在的 Git 仓库。

#### 本地初始化初始化
```
git init [<project>]
```
- 默认将当前路径作为仓库管理。
- 给定`project`时，会在当前路径下创建一个子文件夹，并以改路径作为仓库管理
- 会创建一个`.git`的子文件夹，它是Git仓库的核心文件。

#### 远端克隆
```
git clone <url> [<local_name>]
```
- 默认会将远程 Git 仓库中的每一个文件的每一个版本都将被拉取下来。

## 工作区
所有的修改都是在工作区完成的，工作区的文件不外乎两种状态：已跟踪和未跟踪。

已跟踪的文件就是已经加入到Git版本控制的文件，只有已跟踪的文件才可以对其每一次的更新进行管理。

##### 查看当前工作区状态
```
git status [-s|--short]
```
- 默认会列出详细的状态及说明。
- 可使用`-s`或`--short`简化输出，格式如：`MM filename`，第一个“M”为暂存区的状态，第二为工作区的状态。
    - A:新添加到暂存区中的文件。
    - M:修改过的文件。
    - 未跟踪文件的文件则为“??”。


##### 建立跟踪/添加到暂存区
```
git add <file_or_dirname>
```
- 开始跟踪新文件，或者把已跟踪的文件放到暂存区。
- 如果给定的是文件夹，则会递归其下的所有文件。
- 多次修改同一文件，可重复使用该命令，以更新暂存区内容。
- `-A`:添加所有文件。
- `-u`:添加工作区中所有已经被 git 管理的文件。

还能用于合并时把有冲突的文件标记为已解决状态等。


##### 忽略文件
未跟踪的文件也就不会被Git管理，但是在执行其他命令时会进行提醒。如果是真的不需要Git进行管理的文件，可通过`.gitignore`文件进行配置。这要Git就会忽略掉所有符合规则的文件。

`.gitignore`的格式规范如下：
- 空行或以`#`开头的行都会被忽略。
- 可以使用标准的 glob 模式匹配（shell 中简化的正则表达式），它会递归地应用在整个工作区中。
- 可以以（/）开头防止递归。
- 可以以（/）结尾指定目录。
- 要忽略指定模式以外的文件或目录，可以在模式前加上叹号（!）取反。

不同语言及项目的`gitignore`文件模板可以参考[这里](https://github.com/github/gitignore)。


***注意`.gitignore`文件本身是要被添加到Git仓库的。***


##### 取消跟踪/删除文件
```
git rm --cached <file_or_dirname>
```
- 取消已跟踪文件（删除暂存区中文件），但是保留工作区中的内容。

```
git rm <file_or_dirname>
```
- 同时删除Git仓库和工作区中的文件。
- 已修改或已添加到暂存区的文件，需要使用`-f`强制删除。


##### 撤销修改
```
git checkout -- <filename>
git clean
```
- 撤销文件的所有修改，回到上次提交状态。



##### 查看已修改但未暂存的内容
```
git diff [<commit>] [<commit>] [-- <file> ...]
```
- 默认会比较工作区和暂存区之间所有文件的差异。
- 使用`--staged`或`--cached`可比较暂存区和最后一次提交的差异。
- `commit`可是提交对象、分支、标签等（本质都是提交对象或其应用）。

##### 重命名文件
```
git mv <old_name> <new_name>
```
等同于
```
mv <old_name> <new_name> 
git rm <old_name>
git add <new_name> 
```

##### 保存工作区
如果工作区中的任务还没有完成，并且需要进行其他的尝试或者需要切换到其他分支，但是又不想将修改添加到暂存区或者提交。这是可以先将工作区的状态先保存起来，在需要的时候再取出来就可以了。
```
git stash  # 保存
git stash list  # 列举
git stash apply  # 取回
git stash pop  # 取回并删除
```

##### 直接提交
```
git commit -a 
```
- 把所有已经跟踪文件暂存并提交。
- 一般结合`-m`使用。



## 暂存区
暂存区是对工作区中的修改的“暂时保存”，同时也是最终提交到Git版本仓库的结果，起到了承上启下的作用。同时要记住一点所有的提交都是对暂存区的提交。

##### 提交暂存区
```
git commit [-m <message>]
```
- 默认会启动系统默认的文本编辑器，以输入说明信息。
- 或者使用`-m`直接输入说明信息。
- `-a`从工作区直接提交。
- `--amend`:修改上次提交的日志信息（自上次提交以来没有其他修改）。


##### 查看历史提交
```
git log [<branch>]
```
1. 默认会列出当前分支的所有提交，使用默认格式并按照时间顺序排列。
2.`--all`列举出所有分支的提交记录。
2. 使用不同的输出格式可以使用以下可选参数：
- `-p`或`--patch`:会展示出每次提交的差别。
- `--stat`:总结性的结果。哪些文件被修改了，已经删除多少插入多少。
- `--pretty`:
    - `oneline`：使用一行展示。
    - `short`，`full` 和 `fuller`:格式类似只是详尽程度不同。
    - `format`:使用自定义格式，占位符参考[这里](https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2#pretty_format)。

3. 默认是展示所有提交记录，也可以使用如`-2`的参数限制要显示的日志条目数量。详细的过滤参数参考[这里](https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2#limit_options)。
4. `--graph`使用简单的图形展示，结合`oneline`或`format`使用效果更佳。


##### 取消暂存
```
git reset HEAD [<filename>]
```
- 取消暂存，放回到工作区。（默认是暂存区中的所有文件）

```
git reset --hard [<commit_sha1>]
```
- 同时清除暂存区和工作区的修改，回到上次提交状态。（默认为`HEAD`）


## Git仓库
Git仓库的核心数据几乎都存储在`./.git`中。

### 标签
标签是打在某个提交上的，相当于对在历史提交中做一个“书签”。方便日后对某个特殊提交查找。

标签有两种：
- 轻量标签（lightweight）: 只是一个提交对象的引用。
- 附注标签（annotated）: 真实的Git标签对象，内容包括打标签者的名字、电子邮件地址、日期时间， 此外还有一个标签信息。（推荐使用）

##### 查看仓库书签
```
git tag 
```
- 默认列举出所有标签。

```
git tag -l 'v1.8.*'
```
- 列举出特定格式的标签。

```
git show <tag_name>
```
- 查看标签的详细信息。


##### 创建标签
默认都是打在当前提交上的（HEAD），也可以指定提交对象。
###### 轻量标签
```
git tag <tag_name> [<commit_sha1>]
```

###### 附注标签
```
git tag -a -m <message> <tag_name> [<commit_sha1>]
```

##### 共享标签
因为`git push`默认是不会推送标签数据的，所有必须显示的推送标签数据。
```
git push <remote_name> <tag_name>
git push <remote_name> --all  # 推送所有标签
```

##### 删除本地标签
```
git tag -d <tag_name>
```

同时也需要删除远端该标签时，可以先删除本地的标签，在共享到远端。或者直接使用下述命令直接删除远端的标签：
```
git push origin --delete <tag_name>
```

##### 切换到标签状态
```
git checkout <tag_name>
```
- 切换到标签对应提交的状态，但会仓库进入“分离头指针”状态。

在“分离头指针”状态下，如果你做了某些更改然后提交它们，但新提交将不属于任何分支，并且将无法访问，除非通过确切的提交哈希才能访问。通常应该根基该标签创建一个新的分支，再进行修改提交。
```
git checkout -b <new_branch> <tag_name>
```

### 分支
了解了Git的原理后，我们都知道Git的核心就是由三个对象组成的。其中每一个提交对象都至少有一个父提交对象（除了第一个），则也就构成了一个”版本线“。

如果多个提交对象的父对象是同一个对象，那么也就是一分多。如果一个提交对象有多个父对象，也就是多合一。则也就是分支的本质，就是一个指向提交对象的可变指针。并且分支会随着提交操作自动向前移动。

Git默认分支是`master`，它并没有什么特殊，只是在初始化时自动创建的一个默认分支而已。


##### 创建分支
```
git branch <branch_name> [<commit_sha1>]
```
- 默认在当前所在提交对象上创建一个新的分支。

##### 删除分支
```
git branch -d <branch_name>
```

##### 切换分支
创建好的分支，我们可以通过`git checkout`命令切换到该分支上:
```
git checkout <branch_name>
```
- 如果想切换到新的分支（不存在的分支），可以使用`-b`，创建该分支并切换到该分支上。
- 切换分支时必须要保证工作区和暂存区干净（工作区没有已修改的文件，暂存区没有未提交的文件），可以提交当前所有的修改，或者通过"暂存"和"修补提交"解决。
- 同切换标签，如果给定的是一个提交对象，则会进入分离头指针状态。

##### 合并分支
```
git merge <branch_name>
```
- 合并指定分支到当前分支。
- 如果当前分支和指定分支在一条线上（直接祖先），那么Git只会将当前分支的指针向前移动。这是最快速的合并方式（fast-forward），因为他不会有冲突需要解决。
- 如果不在一条线上，则Git会根据两个分支的末端及其最近共同祖先做合并，并创建一个新的提交对象指向该结果。


合并操作并不总是一帆风顺，如果不同分支对相同地方做了不同修改，合并是就好产生冲突。Git并不会帮我们自动修改冲突，需要我们手动的解决所有的冲突后再合并。

可通过`git stats`查看哪些文件存在冲突。解决冲突后使用`git add`命令将文件标记为”已解决“。解决所有文件冲突后使用`git commit`继续完成合并操作。


##### 变基操作
整合不同分支的修改，可以使用前面说到的分支合并，也可以通过”变基“达到相同的效果。变基就是修改分支的历史提交记录（基），将其他分支上的提交修改到当前分支上。


如有一个`dev`分支和一个`master`分支，并且都做了不同的提交。
###### 分支合并
```
git checkout master
git merge dev  # 三方合并
```

###### 变基
```
git checkout dev
git rebase master

git checkout master
git merge dev  # 快速合并
```

可以看出变基操作和合并分支的结果是完全一样的，但是变基可以使提交历史更加整洁。但是变基也是有**风险**的，比如你对一个共享的分支进行的变基操作，则会使后续的提交推送变得复杂繁琐，难以维护。所有如果你选择变基，请遵守准则：
- 如果提交存在于你的仓库之外，而别人可能基于这些提交进行开发，那么不要执行变基。

实际使用过程中因人而异，如果你更认可提交历史记录本身的价值，那么你可以选择合并分支的方式。相反你可以通过变基使历史记录更加的简洁整齐。


## 远程仓库
远端仓库并不一定是在其他电脑上，如果你愿意也可以是在你本地的其他目录。Git 的默认远程仓库名为`origin`。

### 通信协议
在和远程仓库进行数据交互时可以使用以下协议：
- 本地协议
- SSH协议
- Git协议
- HTTP协议

#### 本地协议（File协议）
只能用于远程仓库位于本地的情况，直接使用仓库的路径即可：
```
[file://]/path/<project.git>
```

优点是简单，直接使用了现有的文件权限和网络访问权限。

缺点是有局限性，并且每一个用户都有“远程”目录的完整 shell 权限，无法保证仓库的安全性。


#### [SSH](https://baike.baidu.com/item/SSH/10407)协议
```
ssh://[user@]server/project.git
[user@]server:project.git
```
- 不指定用户时，Git会使用当前登录的用户名。

优点是架设服务相对简单，而且大多数服务器都已支持。其次的安全性，所有传输数据都要经过授权和加密（口令或秘钥）。传输效率也比较高效。

缺点是无法匿名访问。

#### Git协议
它包含在 Git 里的一个特殊的守护进程，监听9418端口。类似于 SSH 服务，但是访问无需任何授权。要让版本库支持 Git 协议，需要先创建一个 `git-daemon-export-ok`文件。

优点是它的网络传输是最快的，而且支持匿名访问（无需验证）。

缺点是缺乏授权机制，要么都可以要都不可以。而且架设复杂（[架设](https://git-scm.com/book/zh/v2/服务器上的-Git-Git-守护进程)），一般很少使用。


#### HTTP/HTTPS协议
在 Git 1.6.6 版本之前只有一个方式可用，十分简单并且通常是只读模式的。 Git 1.6.6 版本引入了一种新的、更智能的协议，让 Git 可以像通过 SSH 那样智能的协商和传输数据。一般称前者为**哑 HTTP 协议**，而后者为**智能 HTTP协议**。

哑 HTTP 协议里 web 服务器仅把裸版本库当作普通文件来对待，提供文件服务。 只需要把一个裸版本库放在 HTTP 根目录，并设置一个叫做 post-update 的挂钩就可以。 

智能 HTTP 的运行方式和 SSH 及 Git 协议类似，只是运行在标准的 HTTP/S 端口上并且可以使用各种 HTTP 验证机制。

```
https://example.com/gitproject.git
```

优点（智能 HTTP 协议）是可以像 SSH 协议一样安全而且验证方式更简单，也可以像 Git 协议那样支持匿名访问。而且运行在标准的 HTTP 端口上，更具有普适性。

缺点是[架设](https://git-scm.com/book/zh/v2/服务器上的-Git-Smart-HTTP)一个Web服务相对于其他协议更为复杂一些。


##### 查看远程仓库
```
git remote [-v|--verbose]
```
- 默认只列出所有远程仓库的名字。可使用`-v`或`--verbose`查看详情。

```
git remote show <remote_name>
```
- 查看远端仓库的详细情况。


##### 添加远程仓库
```
git remote add <remote_name> <url>
```

##### 修改远程仓库名
```
git remote rename <old_name> <new_name>
```

##### 删除远程仓库
```
git remote remove <remote_name>
```

##### 拉去数据
```
git fetch [<remote_name>] [<branch_name>]
```
- 默认拉取远端仓库的所有分支的数据。
- 只会将数据下载到你的本地仓库（不会自动合并或修改你当前的工作），需要手动合并。

```
git pull [<remote_name>] [<branch_name>]
```
- 拉取远端仓库数据，并默认合并当前分支和其跟踪远程分支。有冲突时需手动解决。

##### 推送数据
```
git push [<remote_name>] [<branch_name>]
```
- 和远端仓库有跟踪关系时可不指定仓库和分支。
- 默认是不会推送本地标签到远端。详见标签部分介绍。
- `--all`推送所有分支。
- `-f`强制推送（慎用）。

# Git服务器
你可以选择自建一个Git服务器，也可以使用[代码托管服务](https://git.wiki.kernel.org/index.php/GitHosting)（[GitHub](https://git-scm.com/book/zh/v2/GitHub-%E8%B4%A6%E6%88%B7%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E9%85%8D%E7%BD%AE)等）。

## 自建Git服务器
一个公共的Git仓库一般是裸仓库（没有工作区），因为它只是用来存放Git数据的，并不需要在其上进行代码提交。创建一个裸仓库可以使用：
```
git init --bare [<project>]
```
- 仓库的文件夹名一般以`.git`结尾。

因为SSH架设比较简单，所有一般自建Git服务器都会使用SSH进行通信。再结合操作系统的权限管理就可以满足基本的需求了。当然你也可以使用[Git协议](https://git-scm.com/book/zh/v2/服务器上的-Git-Git-守护进程)或者[HTTP协议](https://git-scm.com/book/zh/v2/服务器上的-Git-Smart-HTTP)通信。

用户比较少的情况下，可以直接通过用户名和密码登陆。用户比较多的话就不现实了，这时可以创建一个公共的`git`用户，然后让需要写权限的人发送一个 SSH 公钥，再将其加入 git 账户的 `~/.ssh/authorized_keys` 文件。这样所有人都将通过 git 账户访问主机
。具体配置方法可参考[官方教程](https://git-scm.com/book/zh/v2/服务器上的-Git-配置服务器)。

#### SSH 密钥
默认情况下，用户的 SSH 密钥存储在其 `~/.ssh` 目录下。命名方式为`*id_dsa` 或 `*id_rsa`，其中`.pub` 扩展名的为公钥，另一个则为私钥（不要随意泄露）。

SSH 认证的原理很简单，可以简单理解为：用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。

##### 生成秘钥
```
ssh-keygen [-t rsa] [-C "youremail@example.com"]
```
- `-t`:密钥类型。默认生成用于SSH-2的RSA密钥。
- `-C`:添加注释，可以用来标识密钥的用途或其他有用的信息。
- 过程中还会提示输入私钥密码，如不需要可直接跳过。
- 生成好的秘钥对会保存在默认路径下，或者通过`-f`指定也可以。

##### 多秘钥管理
在生成多个秘钥时，要注意对之前的秘钥进行备份保存，防止覆盖丢失。

`~/.ssh/config`文件可以用来定义不同主机的配置。如下：
```
Host mygithub.com
    HostName github.com
    PreferredAuthentications publickey
    IdentityFile ~/.ssh/id_rsa

Host github.com
    HostName github.com
    PreferredAuthentications publickey
    IdentityFile ~/.ssh/worker_id-rsa
```

##### 测试
```
ssh -T <host>
```

如果你并不满足于命令行方式管理，想要架设一个Web端的管理工具。你可以使用Git原始的[GitWeb](https://git-scm.com/book/zh/v2/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git-GitWeb)工具，或者可以使用更现代的开源工具[GitLab](https://git-scm.com/book/zh/v2/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git-GitLab)架设。



# 参考
- [Git官方文档](https://git-scm.com/book/zh/v2)